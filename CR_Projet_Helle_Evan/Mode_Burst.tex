\section{Mode Burst}
La SRAM est capable de fonctionner en mode Burst. Ce mode permet de lire ou d'écrire plusieurs mots consécutifs en une seule opération, ce qui améliore les performances lors de l'accès à des blocs de données.\\
Nous allons implémenter ce mode dans notre contrôleur SRAM pour optimiser les opérations de lecture et d'écriture.\\

\subsection{Implémentation du mode Burst}

Premièrement, le signal \verb|ADV/LV#0| varira en fonction du mode de fonctionnement.\\
Pour l'instant, il est à l'état de constante à 0.\\
Nous allons donc assigner cette variable à 0 dans notre FSM à l'état \verb|IDLE|, \verb|READ| et \verb|WRITE|.\\  

Après cette étape, un rapide lancement de la simulation du controlleur sram indique que ce changement n'a rien cassé.\\

\subsubsection{FSM}

Pour l'implémentation du mode Burst, nous allons ajouter deux nouveaux états à notre FSM existante : \verb|READ_BURST| et \verb|WRITE_BURST|.\\
Ces états géreront les opérations de lecture et d'écriture en mode Burst.\\

De plus il faut désormais gérer des signaux que nous avions laissé de côté précédemment :\\


\begin{itemize}
    \item Ld\_n, permet d'autoriser ou de bloquer le changement d'adresse lors d'une opération en cours.
    \item CE\_n, nécessaire à 0 si Ld\_n est à 0 pour que l'adresse soit prise en compte.
    \item OE\_n, 
\end{itemize}

\newpage

Voici un extrait de la FSM avec la gestion de ces signaux: \\

\begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor = lightgray,
fontsize=\footnotesize,
linenos
]{VHDL}
process(state)
    begin 
        case state is
            When INIT => 
                ...
            when IDLE =>
                Rw_n <= '1'; --protection materiel
                CE_n   <= '1';
                OE_n   <= '1';
                Ld_n   <= '1';
                T_s    <= '0';
                
            when READ =>
                Rw_n <= '1'; -- on assignera cette valeur au trigg de la SRAM par la suite
                T_s  <='1';
                CE_n   <= '0';
                OE_n   <= '0';
                Ld_n   <= '0'; -- BEGIN
                --Addr   <= User_Address;

            when WRITE =>
                Rw_n <= '0';
                T_s  <='0';
                CE_n   <= '0';
                OE_n   <= '1';
                Ld_n   <= '0'; -- BEGIN
                --Addr   <= User_Address;

            when READ_BURST =>
                ...
            when WRITE_BURST =>
                ...
        end case;
    end process;  
\end{minted}

En ajoutant la gestion de ces signaux, Il faut s'assurer que  le mode de fonctionnement hors Burst reste intact.\\
Nous allons donc relancer une simulation pour vérifier que tout fonctionne correctement.\\
Le test bench à d'ailleur été amélioré pour afficher la dernière lecture de données sur l'adresse 0.\\

% - Image - %
\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{Image/simu_burst_1.png }
\caption{Simulation après ajout des signaux CE\_n, OE\_n et Ld\_n}
\end{figure}

La logique de changement d'état de la FSM doit également être mise à jour pour inclure les nouveaux états de Burst.\\
Voici un extrait de la logique de changement d'état mise à jour : \\

\begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor = lightgray,
fontsize=\footnotesize,
linenos
]{VHDL}

process(Clk,reset)
    begin 
        if reset ='1' then 
            state  <= INIT;
        
        elsif Clk'EVENT and Clk = '1' then 
            case state is
                When INIT => 
                    state  <= IDLE;
                    
                when IDLE =>
                    if Ctrl ='1' AND Start ='1' AND Burst ='0' then 
                        state <= READ;
                    elsif Ctrl ='0' AND Start ='1' AND Burst ='0' then 
                        state <= WRITE;
                    else 
                        state <= IDLE;
                    end if;
                    
                    when READ =>
                        if Burst = '1' AND Start = '1' then
                            state <= READ_BURST;
                        elsif Ctrl = '1' AND Start = '1' then
                            state <= READ;
                        elsif Ctrl = '0' AND Start = '1' then
                            state <= WRITE;
                        else
                            state <= IDLE;
                        end if;
                    
                    when WRITE =>
                        if Burst = '1' AND Start = '1' then
                            state <= WRITE_BURST;
                        elsif Ctrl = '1' AND Start = '1' then
                            state <= READ;
                        elsif Ctrl = '0' AND Start = '1' then
                            state <= WRITE;
                        else
                            state <= IDLE;
                        end if;
                    
                when READ_BURST =>
                    if Ctrl ='1' AND Start='1' AND Burst ='0' then 
                        state <= READ;
                    elsif Ctrl ='0' AND Start='1' AND Burst ='0' then 
                        state <= WRITE;
                    elsif Burst ='1' AND Start='1' then 
                        state <= READ_BURST;
                    else 
                        state <= IDLE;
                    end if;
                    
                when WRITE_BURST =>
                    if Ctrl ='1' AND Start='1' AND Burst ='0' then 
                        state <= READ;
                    elsif Ctrl ='0' AND Start='1' AND Burst ='0' then 
                        state <= WRITE;
                    elsif Burst ='1' AND Start='1' then 
                        state <= WRITE_BURST;
                    else 
                        state <= IDLE;
                    end if;
                    
            end case;
        end if; 
    end process;

\end{minted}

DQ est passé en bidirectionnel inout ce n'était pas le cas avant nous utilisionss un signal qui décalait la donnée pour la mettre en sortie ou en entrée.\\

Nous avons été contraint d'ajouter un signal intermédiaire T\_s\_reg qui gère la direction du bus de données bidirectionnel.\\
Si la direction du bus change instantanément sans passer par un registre, nous risquons un conflit de bus : le FPGA et la SRAM essaient de parler en même temps sur le même fil pendant une fraction de seconde, ce qui crée des courts-circuits en simulation.\\
T\_s\_reg permet de s'assurer que l'ordre de passer en haute impédance est parfaitement aligné avec le cycle d'horloge où la donnée doit sortir.\\

Nopus avons également ajouté un registre pour l'adresse de burst : burst\_addr.\\
Il faut séparer clairement adresse de départ et adresse courante du burst.\\

Il faut incrementer la donnée sur le write burst pour voir si tout va bien.\\
Une simple boucle dans le test bench permet de faire cela.\\

Il y'a eu une confusion avec le signal Ld\_n.\\
Nous avons forcé l'incrementation de l'adresse par le controlleur durant le mode burst.\\
Or, la SRAM est capable de gérer l'incrementation automatique de l'adresse en mode burst si Ld\_n est à 1.\\
Si nous voulons faire un programme plus preformant, il faudrait reprendre le code et changer l'incrementation forcée par celle de la sram.\\
Par souci de temps, nous laisserons cela ainsi pour le moment. Cela est amplement suffisant pour valider le fonctionnement du controlleur.\\

Voici la partie du test bench pour le mode burst:\\
Nous avons fait le choix d'ajouter cette partie au test bench existant plutot que de créer un nouveau test bench dédié au mode burst.\\

\begin{minted}[frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor = lightgray,
fontsize=\footnotesize,
linenos
]{VHDL}
 -- MODE BURST TB ------------------------------------------------------
	   wait for 1*(TCLKH+TCLKL);
	   Data_in_s <= "00000000000000000000000000000001"; -- 32 bits
	   
       wait for 1.25*(TCLKH+TCLKL);
       Addr_in_s <= "0000000000000000001"; -- 19 bits
       wait for 1.25*(TCLKH+TCLKL); --write
	   user_Burst <='0';   
	   user_Ctrl <= '0';
	   R_W_enable <='1';
	   --nRW_s    <= '0';
	   
       wait for 1.25*(TCLKH+TCLKL); --write BURST
	   user_Burst <='1';
	   -- Boucle d'incrémentation manuelle synchronisée sur l'horloge
       for i in 0 to 4 loop
           wait until rising_edge(CLKO_SRAM);
           Data_in_s <= std_logic_vector(unsigned(Data_in_s) + 1);
       end loop;
	   
	   wait for 8.75*(TCLKH+TCLKL);--read
	   user_Burst <='0';
	   --wait for 1.25*(TCLKH+TCLKL);
	   Addr_in_s <= "0000000000000000001"; -- 19 bits on va relire les données écrit avec le burst
	   user_Ctrl <= '1';
	   R_W_enable <='1';
	   --nRW_s    <= '1';
	   
	   wait for 2.5*(TCLKH+TCLKL);--read BURST
	   user_Burst <='1';   
	   user_Ctrl <= '1';
	   R_W_enable <='1';
	   --nRW_s    <= '1';
\end{minted}

L'écriture en mode burst fonctionne parfaitement, de même pour la lecture.\\
nous incrémentation la donnée à chaque cycle d'horloge pendant le burst pour vérifier que tout fonctionne correctement.\\

% - Image - %
\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{Image/Write_burst.png}
\caption{Simulation write mode burst}
\end{figure}

Ensuite nous lisons les données en mode burst en reprenant les mêmes address que pour l'écriture.\\

% - Image - %
\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{Image/read_burst.png}
\caption{Simulation read mode burst}
\end{figure}

à partir de là, nous pouvons considérer que le mode burst est fonctionnel.\\
Il reste cependant quelques améliorations à apporter pour rendre le contrôleur plus robuste et efficace.\\
Par exemple, l'utilisation de l'incrementation automatique de l'adresse par la SRAM elle-même en mode burst, plutôt que de gérer cela manuellement dans le contrôleur.\\
Cela nécessiterait une révision de la gestion du signal Ld\_n et une adaptation de la logique de la FSM pour s'aligner avec le comportement de la SRAM en mode burst.\\